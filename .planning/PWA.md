# PWA Architecture & Caching Guide

## Stack

- **Framework**: Next.js 16 + **Serwist v9.5** (`@serwist/next`)
- **Service Worker source**: `src/app/sw.ts` (TypeScript)
- **Compiled output**: `public/sw.js` (generated by `next build`, never hand-edit)
- **Manifest**: `src/app/manifest.ts` (Next.js route, served at `/manifest.webmanifest`)
- **Offline data layer**: IndexedDB via `idb-keyval` (`src/lib/offlineDb.ts`)

---

## What Gets Cached

### Precached at Install (automatic via Serwist build)

During `next build`, Serwist injects a manifest into `sw.js` containing ~70 entries:

- All Next.js static JS chunks (page bundles, framework code)
- CSS files
- Fonts (woff2)
- Public images (icons, screenshots, SVGs)
- `_buildManifest.js` / `_ssgManifest.js`
- The `/~offline` fallback page

Each entry has either a content-hash in the filename or a `revision` hash, so Serwist knows exactly when files change.

### Runtime Caching (on first request)

These are cached when first accessed, then served from cache on subsequent requests:

| Route Pattern          | Strategy     | Cache Name       | Timeout | Notes                                  |
| ---------------------- | ------------ | ---------------- | ------- | -------------------------------------- |
| Scripts, styles, fonts | CacheFirst   | `static-assets`  | --      | Cached indefinitely until SW updates   |
| Images                 | CacheFirst   | `images`         | --      | Cached indefinitely until SW updates   |
| GET `/api/vehicles`    | NetworkFirst | `api-vehicles`   | 3s      | Try network, fall back to cache        |
| GET `/api/dashboard`   | NetworkFirst | `api-dashboard`  | 3s      | Try network, fall back to cache        |
| GET `/api/fillups*`    | NetworkFirst | `api-fillups`    | 3s      | Try network, fall back to cache        |
| GET `/api/analytics`   | NetworkFirst | `api-analytics`  | 5s      | Try network, fall back to cache        |
| POST/PUT/DELETE `/api` | NetworkOnly  | --               | --      | Never cached (writes go through queue) |
| Next.js static JS      | CacheFirst   | (default cache)  | --      | From Serwist `defaultCache`            |
| HTML / RSC payloads    | NetworkFirst | (default cache)  | --      | From Serwist `defaultCache`            |

Additionally, the **application layer** caches structured data in IndexedDB:
- Vehicle list
- Recent fillups per vehicle (up to 10 per vehicle)
- Pending fillup queue (offline writes waiting to sync)

### What is NOT cached

- POST/PUT/DELETE API calls (mutations) -- these are queued in IndexedDB instead
- Auth-related API calls (`/api/auth/*`) -- NetworkOnly by default
- Any API data that hasn't been fetched at least once while online

---

## Can You Navigate Between Pages Offline?

**Yes**, with caveats:

1. **Pages you've visited before**: Fully available. The JS chunks are precached at install, and API data is cached via both the service worker (NetworkFirst) and IndexedDB. Navigation works seamlessly.

2. **Pages you've never visited**: The JS chunks are still precached (Serwist precaches all page bundles), so the page shell will render. However, the API data for that page won't be in cache, so the page may show empty/loading states or fall back to whatever the component does when fetch fails.

3. **Complete failure fallback**: If navigation fails entirely (no cached page shell available for some reason), the service worker serves `/~offline` -- a simple "You're offline" page with a "Try Again" button. Located at `src/app/~offline/page.tsx`.

**In practice**: As long as the user has loaded the app at least once while online (triggering the precache install), all page navigation will work offline. Data availability depends on whether they've visited those specific pages before.

---

## Do You Need to Update a Version Number?

**No.** Cache invalidation is fully automatic. There is no version string to manually bump.

Here's how it works:

### How the Service Worker Updates Itself

1. **On every page load**, the browser checks if `sw.js` has changed (byte-level comparison).
2. **During `next build`**, Serwist recompiles `src/app/sw.ts` into `public/sw.js`. If any source files changed, the JS chunk hashes change, which changes the precache manifest embedded in `sw.js`, which changes the file's content.
3. **When the browser detects the change**, it triggers the SW update lifecycle:
   - New SW installs in the background
   - `skipWaiting: true` means it activates immediately (no waiting for tabs to close)
   - `clientsClaim: true` means it takes control of existing pages immediately
   - During activation, Serwist deletes old precache entries that are no longer in the manifest
4. **Runtime caches** (API data) are replaced on each successful network fetch (NetworkFirst strategy).

### The Update Chain

```
Code change → next build → new chunk hashes → new precache manifest in sw.js
→ browser detects sw.js changed → new SW installs → old caches cleaned up
```

**Key point**: Just deploying a new build is enough. The service worker updates itself because its compiled content changes whenever any source file changes.

---

## Key Files Reference

| File                              | Purpose                                             |
| --------------------------------- | --------------------------------------------------- |
| `src/app/sw.ts`                   | Service worker source (edit this, not public/sw.js) |
| `public/sw.js`                    | Compiled SW (build output, don't hand-edit)         |
| `src/app/manifest.ts`             | Web app manifest configuration                     |
| `src/app/~offline/page.tsx`       | Offline fallback page                               |
| `src/lib/offlineDb.ts`            | IndexedDB CRUD for offline data                     |
| `src/lib/syncEngine.ts`           | Sync queue processor with retry/conflict detection  |
| `src/hooks/useOfflineQueue.ts`    | React hook for queue state and auto-sync            |
| `src/hooks/useNetworkStatus.ts`   | Online/offline detection                            |
| `src/hooks/useCachedData.ts`      | Network-first fetch with IndexedDB fallback         |
| `src/contexts/OfflineContext.tsx`  | React context composing all offline state           |
| `src/components/ConnectionToast.tsx`   | Online/offline transition toasts               |
| `src/components/OfflineIndicator.tsx`  | Persistent "Offline" badge                     |
| `src/components/ConflictResolver.tsx`  | Sync conflict resolution modal                 |
| `src/components/InstallPrompt.tsx`     | Smart install banner                           |
| `next.config.ts`                  | Serwist plugin configuration                        |

---

## Offline Write Flow

When a user submits a fillup while offline:

1. `useOfflineQueue.queueFillup()` stores it in IndexedDB
2. `ConnectionToast` shows "You're offline -- data saved locally"
3. When connection returns, `useOfflineQueue` auto-triggers sync
4. `syncEngine.syncPendingFillups()` sends queued items with exponential backoff (1s base, 30s max, 3 retries)
5. If conflicts detected (duplicate odometer/date), `ConflictResolver` modal appears
6. User resolves with: keep mine / keep server / keep both

---

## Potential Improvements to Consider

1. **Add expiration to custom API caches** -- The four custom caches (`api-vehicles`, `api-dashboard`, `api-fillups`, `api-analytics`) have no `ExpirationPlugin`, unlike the default caches. They could grow unbounded.

2. **Add `public/sw.js` to `.gitignore`** -- It's a build artifact regenerated on every `next build`. Committing it creates noisy diffs and risks deploying a stale SW if someone forgets to rebuild.

3. **Add an update notification** -- Currently `skipWaiting: true` silently replaces the SW. A "New version available" prompt would be safer, preventing issues where the new SW expects a different page structure than what's currently loaded.
