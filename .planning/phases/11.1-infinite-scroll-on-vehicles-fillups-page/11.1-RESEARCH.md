# Phase 11.1: Infinite Scroll on Vehicles Fillups Page - Research

**Researched:** 2026-01-22
**Domain:** Infinite scroll with cursor-based pagination in Next.js App Router
**Confidence:** HIGH

## Summary

Researched implementation of infinite scroll for the vehicles fillups page, which currently uses a "Load More" button with cursor-based pagination (already implemented). The goal is to replace the manual button with automatic loading via IntersectionObserver API.

**Current state:** The fillups page (`src/app/vehicles/[id]/fillups/page.tsx`) already has:
- Cursor-based pagination working (API returns `nextCursor`, `hasMore`)
- "Load More" button that calls `loadMore()` function
- Page size of 20 fillups
- Integration with offline caching (10 recent fillups per vehicle cached)
- Pending fillups from IndexedDB merged with server fillups

**Task:** Convert the manual "Load More" button to automatic infinite scroll while preserving offline functionality and accessibility.

**Primary recommendation:** Use native IntersectionObserver API with a sentinel element approach, proper cleanup in useEffect, loading state guards, and accessibility enhancements (skip link, loading announcements).

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| IntersectionObserver API | Native | Detect when sentinel element enters viewport | Native browser API, performant, asynchronous, widely supported |
| React useEffect | 19.2.3 | Manage observer lifecycle and cleanup | Built into React, proper cleanup prevents memory leaks |
| React useCallback | 19.2.3 | Memoize observer callback to prevent stale closures | Ensures observer has fresh state values |
| React useRef | 19.2.3 | Reference sentinel DOM element | Standard React pattern for DOM manipulation |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| idb-keyval | 6.2.2 | Cache fillup data offline | Already in use for Phase 11 offline caching |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Native IntersectionObserver | react-infinite-scroll-component | Library adds dependencies and abstracts control; native API gives full control and zero deps |
| Infinite scroll | Keep "Load More" button | Manual button is more accessible but less modern UX; infinite scroll requires accessibility enhancements |
| DOM accumulation | Virtual scrolling (react-window) | Virtualization adds complexity and breaks with pending fillups UI; not needed for reasonable data sizes (20/page) |

**Installation:**
```bash
# No new packages needed - using native browser APIs
```

## Architecture Patterns

### Recommended Component Structure
```
src/app/vehicles/[id]/fillups/
├── page.tsx                 # Client component with infinite scroll
src/components/
├── InfiniteScrollSentinel.tsx  # (Optional) Reusable sentinel component
```

### Pattern 1: Sentinel Element with IntersectionObserver
**What:** Place an invisible "sentinel" div at the bottom of the list. When it enters the viewport, load more data.
**When to use:** Converting existing pagination to infinite scroll
**Example:**
```typescript
// Source: https://www.freecodecamp.org/news/infinite-scrolling-in-react/
const sentinelRef = useRef<HTMLDivElement>(null)
const [isLoadingMore, setIsLoadingMore] = useState(false)

useEffect(() => {
  const sentinel = sentinelRef.current
  if (!sentinel || !hasMore || isLoadingMore) return

  const observer = new IntersectionObserver(
    (entries) => {
      if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
        loadMore()
      }
    },
    { threshold: 0.1, rootMargin: '100px' }
  )

  observer.observe(sentinel)

  return () => {
    observer.disconnect()
  }
}, [hasMore, isLoadingMore, loadMore])

// Sentinel element in JSX
{hasMore && <div ref={sentinelRef} className="h-4" />}
```

### Pattern 2: Proper Cleanup with observer.disconnect()
**What:** Always call `observer.disconnect()` in useEffect cleanup, not just `unobserve()`
**When to use:** Every IntersectionObserver implementation
**Example:**
```typescript
// Source: https://dev.to/producthackers/intersection-observer-using-react-49ko
useEffect(() => {
  const observer = new IntersectionObserver(callback, options)
  if (targetRef.current) {
    observer.observe(targetRef.current)
  }

  return () => {
    // CRITICAL: Use disconnect(), not just unobserve()
    // disconnect() properly cleans up and prevents React warnings
    observer.disconnect()
  }
}, [dependencies])
```

### Pattern 3: Loading State Guard Pattern
**What:** Prevent duplicate API calls by checking loading state before triggering fetch
**When to use:** All infinite scroll implementations to prevent race conditions
**Example:**
```typescript
// Source: https://blog.logrocket.com/react-infinite-scroll/
const observer = new IntersectionObserver(
  (entries) => {
    // Guard: Only proceed if intersecting, has more data, and NOT currently loading
    if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
      setIsLoadingMore(true)
      loadMore() // This function should handle setIsLoadingMore(false) in finally block
    }
  },
  { threshold: 0.1 }
)
```

### Pattern 4: useCallback for Fresh State
**What:** Wrap the intersection callback in useCallback with proper dependencies to prevent stale closures
**When to use:** When observer callback needs access to current state
**Example:**
```typescript
// Source: https://blog.logrocket.com/implementing-infinite-scroll-next-js-server-actions/
const handleIntersection = useCallback((entries: IntersectionObserverEntry[]) => {
  if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
    loadMore()
  }
}, [hasMore, isLoadingMore, loadMore])

useEffect(() => {
  const observer = new IntersectionObserver(handleIntersection, options)
  // ... rest of implementation
}, [handleIntersection])
```

### Pattern 5: Accessibility Enhancements
**What:** Add ARIA live region for loading announcements and skip link for keyboard users
**When to use:** All infinite scroll implementations for WCAG compliance
**Example:**
```typescript
// Source: https://www.digitala11y.com/infinite-scroll-accessibility-is-it-any-good/
// ARIA live region for screen reader announcements
<div aria-live="polite" aria-atomic="true" className="sr-only">
  {isLoadingMore && "Loading more fillups"}
  {!hasMore && "All fillups loaded"}
</div>

// Skip link for keyboard users to bypass infinite scroll
<a
  href="#footer-section"
  className="sr-only focus:not-sr-only focus:absolute focus:z-50"
>
  Skip to footer
</a>
```

### Anti-Patterns to Avoid
- **Not disconnecting observer:** Using `observer.unobserve(target)` alone doesn't fully clean up; always use `observer.disconnect()` in cleanup
- **Missing loading guards:** Observer callback fires multiple times; always check `!isLoadingMore` before triggering fetch
- **Stale closures:** Observer callback captures state at creation time; use useCallback with dependencies
- **Ignoring React Strict Mode:** In development, useEffect runs twice; ensure cleanup handles double-mount scenarios
- **Accumulating infinite DOM:** For very large lists (1000+ items), consider virtual scrolling; for moderate lists (100-500), DOM accumulation is acceptable
- **No accessibility:** Infinite scroll without skip links or loading announcements fails WCAG 2.1.1 (Keyboard)

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Detecting element visibility | Custom scroll event listener | IntersectionObserver API | Scroll listeners run on main thread (janky); IntersectionObserver is async and performant |
| Virtual scrolling for massive lists | Custom windowing logic | react-window or react-virtualized | Complex edge cases: scroll restoration, dynamic heights, keyboard nav |
| Debouncing intersection events | Custom debounce function | Loading state guard pattern | State guards are simpler and more reliable than timers |
| Offline-first pagination | Custom IndexedDB cursors | Keep existing idb-keyval cache (10 recent) | Pagination in IndexedDB is complex; cache recent items, fetch rest online |
| Accessibility for infinite scroll | Custom keyboard nav | Native browser focus management + skip links | Browser handles focus; just provide skip mechanism |

**Key insight:** IntersectionObserver is the modern standard for infinite scroll. Custom scroll listeners are a legacy pattern that causes performance issues. The native API handles throttling, async execution, and viewport calculations better than any custom solution.

## Common Pitfalls

### Pitfall 1: Memory Leaks from Missing Cleanup
**What goes wrong:** Observer continues running after component unmounts, calling setState on unmounted component
**Why it happens:** Forgetting cleanup function or using `unobserve()` instead of `disconnect()`
**How to avoid:**
```typescript
useEffect(() => {
  const observer = new IntersectionObserver(callback, options)
  observer.observe(sentinel)

  return () => {
    observer.disconnect() // MUST disconnect, not just unobserve
  }
}, [deps])
```
**Warning signs:** React warnings about setState on unmounted component, increasing memory usage over time

### Pitfall 2: Duplicate API Calls
**What goes wrong:** IntersectionObserver fires multiple times rapidly, triggering duplicate fetches
**Why it happens:** Observer callback fires on entry AND exit of intersection, and during scroll momentum
**How to avoid:** Triple-guard pattern:
```typescript
if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
  // Only proceed if ALL three conditions met
}
```
**Warning signs:** Network tab shows duplicate requests with same cursor, backend logs show rapid-fire identical queries

### Pitfall 3: Stale Closure Bug
**What goes wrong:** Observer callback uses old state values (e.g., `hasMore` is stale), causing infinite loading or premature stop
**Why it happens:** Observer callback is a closure that captures state at creation time
**How to avoid:** Include all state dependencies in useEffect dependency array:
```typescript
useEffect(() => {
  // Observer uses hasMore, isLoadingMore, nextCursor
  // ...
}, [hasMore, isLoadingMore, nextCursor]) // MUST include all used state
```
**Warning signs:** Infinite scroll stops working after first load, or keeps loading when hasMore is false

### Pitfall 4: React Strict Mode Double Mount
**What goes wrong:** In development, useEffect runs twice, creating two observers
**Why it happens:** React 18+ Strict Mode intentionally double-mounts to find bugs
**How to avoid:** Proper cleanup function handles this automatically:
```typescript
// Cleanup ensures second mount cleans up first observer
return () => observer.disconnect()
```
**Warning signs:** Console logs show observer triggering twice in development (this is expected and OK if cleanup works)

### Pitfall 5: Offline/Pending Fillups Integration
**What goes wrong:** Infinite scroll loads more data, but pending fillups (at top) disappear or duplicate
**Why it happens:** Pending fillups are prepended to list; pagination cursor doesn't account for them
**How to avoid:** Current implementation already handles this correctly by:
- Fetching only server fillups with cursor
- Separately fetching pending fillups from IndexedDB
- Merging in display layer: `[...pendingDisplay.reverse(), ...syncedDisplay]`
- Keep this pattern; infinite scroll only affects server fillup loading
**Warning signs:** Pending fillups disappear after loading more, or appear in wrong order

### Pitfall 6: Accessibility - Keyboard Trap
**What goes wrong:** Keyboard users can't reach footer; must tab through all loaded fillups
**Why it happens:** Infinite scroll creates unlimited content between header and footer
**How to avoid:** Add skip link before fillup list:
```typescript
<a href="#footer-or-end" className="sr-only focus:visible">
  Skip to end of fillups
</a>
```
**Warning signs:** User feedback about difficulty reaching footer/settings on keyboard

### Pitfall 7: Cache Invalidation on New Fillup
**What goes wrong:** User adds new fillup, returns to list, but it doesn't appear (cached old data)
**Why it happens:** Adding fillup doesn't invalidate fillup list cache
**How to avoid:** Current implementation already handles this:
- `fetchFillups()` is called on mount with no cursor (fresh data)
- Success message triggers via `searchParams.get('success') === '1'`
- Maintain this pattern
**Warning signs:** New fillups don't appear in list without hard refresh

## Code Examples

Verified patterns from official sources and current codebase:

### Converting Load More Button to Infinite Scroll
```typescript
// Current implementation (from page.tsx line 734-746):
// {hasMore && (
//   <div className="mt-4 text-center">
//     <button onClick={loadMore} disabled={isLoadingMore}>
//       {isLoadingMore ? 'Loading...' : 'Load More'}
//     </button>
//   </div>
// )}

// Replace with sentinel-based infinite scroll:
// Source: Adapted from https://www.freecodecamp.org/news/infinite-scrolling-in-react/
const sentinelRef = useRef<HTMLDivElement>(null)

useEffect(() => {
  const sentinel = sentinelRef.current
  if (!sentinel) return

  const observer = new IntersectionObserver(
    (entries) => {
      if (entries[0].isIntersecting && hasMore && !isLoadingMore) {
        loadMore() // Existing function, no changes needed
      }
    },
    {
      threshold: 0.1,
      rootMargin: '200px' // Start loading 200px before sentinel visible
    }
  )

  observer.observe(sentinel)

  return () => {
    observer.disconnect()
  }
}, [hasMore, isLoadingMore]) // loadMore is from useCallback, stable reference

// In JSX (replace the Load More button section):
{hasMore && (
  <div ref={sentinelRef} className="mt-4 text-center">
    <div className="text-gray-500 text-sm">
      {isLoadingMore ? 'Loading more fillups...' : ''}
    </div>
  </div>
)}
```

### Accessibility Enhancements
```typescript
// Source: https://www.digitala11y.com/infinite-scroll-accessibility-is-it-any-good/
// Add near top of fillup list (after filters, before fillups):
<div className="sr-only" aria-live="polite" aria-atomic="true">
  {isLoadingMore && "Loading more fillups"}
  {!hasMore && displayFillups.length > 20 && "All fillups loaded"}
</div>

// Optional: Skip link for keyboard users (if footer exists)
{displayFillups.length > 20 && (
  <a
    href="#add-fillup-button"
    className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:bg-white focus:p-2 focus:shadow-lg focus:rounded"
  >
    Back to top
  </a>
)}
```

### Preserving Current Pagination Logic
```typescript
// Existing loadMore function (lines 156-160) works perfectly:
async function loadMore() {
  if (!nextCursor || isLoadingMore) return // Guard already exists
  setIsLoadingMore(true)
  await fetchFillups(nextCursor, startDate, endDate)
}

// Existing fetchFillups handles pagination correctly:
// - Appends to list if cursor exists: setFillups(prev => [...prev, ...data.fillups])
// - Updates nextCursor and hasMore from API response
// - Sets isLoadingMore to false in finally block

// NO CHANGES NEEDED to these functions
```

### Integration with Offline Caching
```typescript
// Current implementation already correct (lines 295-338):
// - getDisplayFillups() merges pending and synced fillups
// - Pending fillups are filtered by vehicleId
// - Pagination only applies to synced fillups (server data)
// - Cursor is based on synced fillup dates, not pending

// Keep this pattern unchanged
// Infinite scroll only triggers loadMore(), which only fetches server data
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Scroll event listeners | IntersectionObserver API | ~2017 (API) → 2020+ (widespread adoption) | Major performance improvement; async, throttled automatically |
| Offset-based pagination | Cursor-based pagination | 2018+ (for large datasets) | Prevents "page drift" when data changes; consistent performance |
| Load more button | Infinite scroll | 2015+ (mobile apps) → 2020+ (web) | Better mobile UX; accessibility concerns require extra work |
| Libraries (react-infinite-scroll) | Native IntersectionObserver | 2023+ | Zero dependencies, full control, better tree-shaking |
| Manual debouncing | Loading state guards | 2022+ | Simpler, more reliable than timers |

**Deprecated/outdated:**
- **Scroll event listeners:** `window.addEventListener('scroll', ...)` is legacy; use IntersectionObserver
- **Offset-based pagination:** `LIMIT 20 OFFSET 40` has performance issues at scale; use cursor-based
- **Infinite scroll without accessibility:** Pre-2018 implementations ignored keyboard users; now requires skip links and ARIA

## Open Questions

Things that couldn't be fully resolved:

1. **Should filters reset scroll position?**
   - What we know: Current implementation resets fillup list when filters change (`setFillups([])`)
   - What's unclear: Should the page scroll to top when filter applied? Current behavior doesn't explicitly scroll
   - Recommendation: Add `window.scrollTo({ top: 0, behavior: 'smooth' })` when filters change for better UX

2. **Virtual scrolling threshold**
   - What we know: Current implementation loads 20 fillups per page; no DOM cleanup
   - What's unclear: At what point (500 fillups? 1000?) does DOM accumulation cause performance issues?
   - Recommendation: Monitor but don't pre-optimize. With 20/page, reaching 500 fillups (25 loads) is unlikely in practice. Add performance monitoring if needed later.

3. **Offline behavior when reaching cache limit**
   - What we know: Only 10 fillups are cached per vehicle (from Phase 11-04)
   - What's unclear: Should infinite scroll show "offline, limited history" message after 10 cached items?
   - Recommendation: Add offline indicator: "Showing 10 most recent fillups (offline). Connect to load full history."

## Sources

### Primary (HIGH confidence)
- [Next.js 16 Official Blog](https://nextjs.org/blog/next-16) - Confirmed Next.js 16 release and features
- [React 19 Official Docs](https://react.dev/reference/react/StrictMode) - Strict Mode behavior and useEffect cleanup
- [FreeCodeCamp: Infinite Scrolling in React](https://www.freecodecamp.org/news/infinite-scrolling-in-react/) - IntersectionObserver implementation patterns
- [LogRocket: Infinite Scroll in Next.js](https://blog.logrocket.com/implementing-infinite-scroll-next-js-server-actions/) - Next.js-specific patterns
- [DigitalA11Y: Infinite Scroll Accessibility](https://www.digitala11y.com/infinite-scroll-accessibility-is-it-any-good/) - WCAG compliance patterns

### Secondary (MEDIUM confidence)
- [DEV.to: Intersection Observer Cleanup](https://dev.to/producthackers/intersection-observer-using-react-49ko) - WebSearch verified with React docs
- [Deque: Infinite Scroll Accessibility Issues](https://www.deque.com/blog/infinite-scrolling-rolefeed-accessibility-issues/) - Accessibility expert analysis
- [Medium: Cursor Pagination Deep Dive](https://medium.com/@ferlat.simon/infinite-scroll-with-nextjs-server-actions-a-simple-guide-76a894824cfd) - Server action patterns

### Tertiary (LOW confidence)
- Various Medium articles on infinite scroll patterns - Unverified implementation details
- GitHub discussions on memory leaks - Anecdotal reports, not authoritative

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Native APIs, existing React patterns, well-documented
- Architecture: HIGH - Current implementation already 90% there; minimal changes needed
- Pitfalls: HIGH - Well-documented issues with verified solutions
- Accessibility: MEDIUM - Standards clear, but implementation varies by use case
- Offline integration: HIGH - Phase 11 implementation already handles this correctly

**Research date:** 2026-01-22
**Valid until:** 2026-02-21 (30 days - stable APIs, unlikely to change)

**Key finding:** The current implementation is already well-architected with cursor-based pagination, proper state management, and offline integration. Converting to infinite scroll is a minimal change: replace button with sentinel element + IntersectionObserver. The hardest part is accessibility (skip links, ARIA announcements), not the infinite scroll mechanism itself.
