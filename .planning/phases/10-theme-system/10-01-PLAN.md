---
phase: 10-theme-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/contexts/ThemeContext.tsx
  - src/components/Providers.tsx
  - src/app/globals.css
  - src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Theme persists across page refreshes"
    - "Theme persists across browser sessions"
    - "System preference detected on first visit"
    - "Theme class applied to html element"
  artifacts:
    - path: "src/contexts/ThemeContext.tsx"
      provides: "Theme context with useTheme hook"
      exports: ["ThemeProvider", "useTheme"]
    - path: "src/components/Providers.tsx"
      provides: "Wraps SessionProvider with ThemeProvider"
      contains: "ThemeProvider"
    - path: "src/app/globals.css"
      provides: "Class-based dark mode CSS variables"
      contains: ".dark"
  key_links:
    - from: "src/contexts/ThemeContext.tsx"
      to: "localStorage"
      via: "getItem/setItem"
      pattern: "localStorage\\.(get|set)Item"
    - from: "src/app/layout.tsx"
      to: "ThemeProvider"
      via: "import and wrap"
      pattern: "ThemeProvider"
---

<objective>
Create theme infrastructure with React Context, localStorage persistence, and class-based dark mode CSS.

Purpose: Enable user-selectable dark/light theme that persists across sessions and respects system preference on first visit.
Output: ThemeProvider context, useTheme hook, updated CSS variables with .dark class support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/globals.css
@src/app/layout.tsx
@src/components/Providers.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThemeContext with localStorage persistence</name>
  <files>src/contexts/ThemeContext.tsx</files>
  <action>
Create a new ThemeContext that:
1. Defines Theme type: 'light' | 'dark' | 'system'
2. Creates context with: theme, setTheme, resolvedTheme (actual light/dark)
3. On mount:
   - Check localStorage for 'theme' key
   - If not found, default to 'system'
   - If 'system', detect via window.matchMedia('(prefers-color-scheme: dark)')
4. Listen for system preference changes when theme is 'system'
5. Apply 'dark' class to document.documentElement when resolvedTheme is dark
6. Persist theme choice to localStorage on change
7. Export ThemeProvider component and useTheme hook

Use 'use client' directive. Handle SSR by checking typeof window !== 'undefined'.
Avoid flash of wrong theme by using useLayoutEffect for DOM updates.
  </action>
  <verify>
File exists at src/contexts/ThemeContext.tsx with ThemeProvider and useTheme exports.
TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
ThemeContext exports ThemeProvider and useTheme hook with localStorage persistence and system preference detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update globals.css for class-based dark mode</name>
  <files>src/app/globals.css</files>
  <action>
Replace the @media (prefers-color-scheme: dark) block with a .dark class approach:

1. Keep :root with light mode variables (--background: #ffffff, --foreground: #171717)
2. Add .dark selector that sets dark mode variables (--background: #0a0a0a, --foreground: #ededed)
3. Remove the @media (prefers-color-scheme: dark) block entirely
4. Keep all other existing styles (safe-area-inset, @theme inline, body, standalone mode, animations)

This enables Tailwind's class-based dark mode which is already configured via dark: prefix.
  </action>
  <verify>
File contains .dark selector with dark mode CSS variables.
File does NOT contain @media (prefers-color-scheme: dark).
  </verify>
  <done>
globals.css uses .dark class for dark mode variables instead of prefers-color-scheme media query.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate ThemeProvider into Providers and layout</name>
  <files>src/components/Providers.tsx, src/app/layout.tsx</files>
  <action>
Update Providers.tsx:
1. Import ThemeProvider from '@/contexts/ThemeContext'
2. Wrap SessionProvider children with ThemeProvider (ThemeProvider should be inside SessionProvider since it doesn't depend on session)

Update layout.tsx:
1. Add suppressHydrationWarning to html element (prevents hydration mismatch from theme class)
2. No other changes needed - ThemeProvider will handle applying the dark class

The structure should be:
```
<html suppressHydrationWarning>
  <body>
    <Providers>  {/* Contains SessionProvider > ThemeProvider */}
      {children}
    </Providers>
  </body>
</html>
```
  </action>
  <verify>
- `npm run build` succeeds
- `npm run dev` starts without errors
- Browser DevTools shows 'dark' class on html element when dark mode active
- Refreshing page maintains theme choice
  </verify>
  <done>
ThemeProvider integrated into app, theme class applied to html element, persists across refreshes.
  </done>
</task>

</tasks>

<verification>
1. Start dev server: `npm run dev`
2. Open browser DevTools, check html element for 'dark' class based on system preference
3. In DevTools Console, run: `localStorage.setItem('theme', 'dark')` then refresh - should stay dark
4. Run: `localStorage.setItem('theme', 'light')` then refresh - should stay light
5. Run: `localStorage.removeItem('theme')` then refresh - should follow system preference
6. Build succeeds: `npm run build`
</verification>

<success_criteria>
- ThemeContext provides theme state with 'light', 'dark', 'system' options
- Theme persists in localStorage under 'theme' key
- System preference detected when theme is 'system' or unset
- 'dark' class applied to html element when dark mode active
- No hydration warnings in console
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-theme-system/10-01-SUMMARY.md`
</output>
