---
phase: 11-pwa-offline
plan: 04
type: execute
wave: 2
depends_on: ["11-02"]
files_modified:
  - src/lib/offlineDb.ts
  - src/hooks/useCachedData.ts
  - src/app/dashboard/page.tsx
  - src/app/vehicles/[id]/page.tsx
  - src/components/ConflictResolver.tsx
  - src/lib/syncEngine.ts
autonomous: true

must_haves:
  truths:
    - "Vehicle list available when offline from cache"
    - "Last 10 fillups per vehicle cached for offline viewing"
    - "Analytics work offline with cached data + disclaimer"
    - "Conflict modal appears when sync detects server changes"
  artifacts:
    - path: "src/hooks/useCachedData.ts"
      provides: "Hook for cached vehicle and fillup data"
      exports: ["useCachedData"]
    - path: "src/components/ConflictResolver.tsx"
      provides: "Modal for resolving sync conflicts"
      exports: ["ConflictResolver"]
  key_links:
    - from: "src/app/dashboard/page.tsx"
      to: "src/hooks/useCachedData.ts"
      via: "hook usage for offline data"
      pattern: "useCachedData"
    - from: "src/lib/syncEngine.ts"
      to: "src/components/ConflictResolver.tsx"
      via: "conflict detection triggers modal"
      pattern: "conflict|ConflictResolver"
---

<objective>
Implement data caching for offline viewing and conflict resolution

Purpose: Enable viewing previously loaded data when offline (vehicles, fillup history, analytics). Handle conflicts when syncing fillups that may conflict with data from another device.

Output: Cached data available offline, conflict resolution UI for sync edge cases
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-pwa-offline/11-CONTEXT.md
@.planning/phases/11-pwa-offline/11-RESEARCH.md

# Key existing files
@src/lib/offlineDb.ts
@src/app/sw.ts
@src/app/dashboard/page.tsx
@src/app/vehicles/[id]/page.tsx
@src/lib/syncEngine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend offlineDb with vehicle and fillup caching</name>
  <files>src/lib/offlineDb.ts</files>
  <action>
Add caching functions to offlineDb.ts using idb-keyval:

Vehicle caching:
- `cacheVehicles(vehicles: Vehicle[]): Promise<void>` - store full vehicle list
- `getCachedVehicles(): Promise<Vehicle[] | null>` - retrieve cached vehicles
- Key: 'cached-vehicles'

Fillup caching (per vehicle):
- `cacheFillups(vehicleId: string, fillups: Fillup[]): Promise<void>` - store last N fillups
- `getCachedFillups(vehicleId: string): Promise<Fillup[] | null>` - retrieve cached fillups
- Key: `cached-fillups-${vehicleId}`
- Only cache last 10 fillups per vehicle (to limit storage)

Cache metadata:
- `setCacheTimestamp(key: string): Promise<void>` - record when data was cached
- `getCacheTimestamp(key: string): Promise<number | null>` - get cache age
- Allows showing "Last updated X minutes ago" in offline mode

Type definitions for cached data should match existing Vehicle/Fillup interfaces.
  </action>
  <verify>Functions export correctly, can round-trip vehicle and fillup data</verify>
  <done>offlineDb supports vehicle/fillup caching with timestamps</done>
</task>

<task type="auto">
  <name>Task 2: Create useCachedData hook and update pages for offline support</name>
  <files>src/hooks/useCachedData.ts, src/app/dashboard/page.tsx, src/app/vehicles/[id]/page.tsx</files>
  <action>
Create useCachedData hook (src/hooks/useCachedData.ts):
```typescript
interface UseCachedDataOptions {
  vehicleId?: string  // for vehicle-specific fillups
}

interface UseCachedDataReturn {
  vehicles: Vehicle[] | null
  fillups: Fillup[] | null
  isFromCache: boolean
  cacheAge: number | null  // milliseconds since cache
  refreshCache: () => Promise<void>
}
```

Logic:
1. Try to fetch from network first
2. On success: cache the data, return with isFromCache=false
3. On network error + offline: return cached data with isFromCache=true
4. Track cacheAge for UI display

Update dashboard/page.tsx:
1. Use useCachedData for vehicles
2. When offline: show cached data with notice "Showing cached data"
3. Grey out features that require network (if any)
4. Analytics section: show cached data with "Data may be incomplete" notice

Update vehicles/[id]/page.tsx (vehicle detail):
1. Use useCachedData for vehicle and fillups
2. When offline: show cached fillups with notice
3. "Add Fillup" button still works (goes to offline-capable fillup form)
  </action>
  <verify>Go offline, visit dashboard - see cached vehicles with cache notice</verify>
  <done>Dashboard and vehicle pages work offline with cached data</done>
</task>

<task type="auto">
  <name>Task 3: Implement conflict detection and resolution UI</name>
  <files>src/components/ConflictResolver.tsx, src/lib/syncEngine.ts</files>
  <action>
Create ConflictResolver modal (src/components/ConflictResolver.tsx):
- Modal dialog that shows when sync detects conflict
- Displays:
  - "Your queued fillup" details (date, gallons, odometer)
  - "Server fillup" details (what exists on server)
  - Options: "Keep mine", "Keep server's", "Keep both"
- Callback for resolution choice
- Styled as modal overlay with backdrop

Update syncEngine.ts for conflict detection:
1. Before syncing a fillup, check if server has newer fillups for same vehicle
   - GET /api/fillups?vehicleId=X&since=queuedTimestamp
2. If server has fillups with odometer readings that would make the queued fillup's MPG calculation wrong:
   - Flag as conflict
   - Return conflict info instead of auto-syncing
3. Add `checkForConflicts(pending: PendingFillup): Promise<Conflict | null>`

Conflict resolution flow:
1. syncEngine detects conflict
2. Returns conflict object to caller
3. Caller (OfflineContext) shows ConflictResolver modal
4. User chooses resolution
5. syncEngine applies resolution:
   - Keep mine: POST queued fillup, MPG will recalculate server-side
   - Keep server's: delete queued fillup from queue
   - Keep both: POST queued fillup as-is

Note: Full MPG recalculation is Phase 12 scope. For now, just handle the sync decision.
  </action>
  <verify>Simulate conflict scenario (queue fillup, add different fillup via API), see conflict modal on sync</verify>
  <done>Conflict detection works, ConflictResolver modal shows options, resolution applies correctly</done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Load dashboard online - vehicles cached
3. Go offline - dashboard shows cached vehicles with notice
4. Vehicle detail shows cached fillups offline
5. Create conflict scenario:
   - Queue fillup offline
   - Add fillup via another method (API/another device)
   - Go online - conflict modal appears
6. Resolve conflict - appropriate action taken
</verification>

<success_criteria>
- Vehicles and recent fillups cached for offline viewing
- Dashboard and vehicle pages gracefully degrade offline
- Cache age displayed to user
- Conflict resolution modal functional for sync edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/11-pwa-offline/11-04-SUMMARY.md`
</output>
