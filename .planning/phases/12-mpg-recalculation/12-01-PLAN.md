---
phase: 12-mpg-recalculation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/fillups/[id]/route.ts
  - src/app/api/fillups/[id]/recalculate/route.ts
  - src/app/vehicles/[id]/fillups/page.tsx
autonomous: true

must_haves:
  truths:
    - "Editing gallons recalculates MPG for that fillup"
    - "Editing odometer recalculates MPG for that fillup and the next fillup"
    - "User can manually trigger MPG recalculation for a single fillup"
    - "Recalculated MPG values are accurate based on odometer deltas"
  artifacts:
    - path: "src/app/api/fillups/[id]/route.ts"
      provides: "PATCH handler with MPG recalculation logic"
      contains: "recalculateMpg"
    - path: "src/app/api/fillups/[id]/recalculate/route.ts"
      provides: "POST endpoint for manual MPG recalculation"
      exports: ["POST"]
    - path: "src/app/vehicles/[id]/fillups/page.tsx"
      provides: "Recalculate MPG button in fillup details"
      contains: "Recalculate MPG"
  key_links:
    - from: "src/app/api/fillups/[id]/route.ts"
      to: "prisma.fillup"
      via: "update queries for current and next fillup"
      pattern: "prisma\\.fillup\\.(update|findFirst)"
    - from: "src/app/vehicles/[id]/fillups/page.tsx"
      to: "/api/fillups/[id]/recalculate"
      via: "fetch POST on button click"
      pattern: "fetch.*recalculate"
---

<objective>
Add MPG recalculation on fillup edit and provide manual recalculation option.

Purpose: When users edit fillup data (especially gallons or odometer), the MPG values become stale. This phase ensures MPG stays accurate after edits and gives users a manual override option.

Output: Updated PATCH endpoint with automatic MPG recalculation, new recalculate endpoint, and UI button for manual trigger.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key files:
@src/app/api/fillups/[id]/route.ts - Current PATCH handler (no MPG recalculation)
@src/app/api/fillups/route.ts - POST handler (has MPG calculation logic to reference, lines 329-350)
@src/app/vehicles/[id]/fillups/page.tsx - Fillup list with expanded details
@prisma/schema.prisma - Fillup model with mpg field (Float?)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MPG recalculation to PATCH endpoint</name>
  <files>src/app/api/fillups/[id]/route.ts</files>
  <action>
Modify the PATCH handler to recalculate MPG when gallons, odometer, or isFull changes.

**MPG calculation logic** (copy from POST handler):
- MPG = (current_odometer - previous_full_fillup_odometer) / gallons
- Only calculate if current fillup is full AND there's a previous full fillup with lower odometer
- Round to 2 decimal places

**Implementation steps:**

1. After the existing validation and before the update, check if gallons, odometer, or isFull is being changed:
```typescript
const mpgFieldsChanged = updateData.gallons !== undefined ||
                          updateData.odometer !== undefined ||
                          updateData.isFull !== undefined
```

2. If mpgFieldsChanged, recalculate MPG for the CURRENT fillup:
   - Use final values (updateData.X ?? fillup.X for each field)
   - If final isFull is true, find previous full fillup with odometer < final odometer
   - Calculate MPG if previous exists, otherwise set to null
   - Add mpg to updateData

3. After the current fillup update, if odometer changed, recalculate MPG for the NEXT fillup:
   - Find the next full fillup with odometer > updated fillup's odometer (ordered by odometer ASC, take first)
   - If found and it's a full tank, recalculate its MPG using the updated fillup as the previous
   - Update that fillup's MPG

**Important:** The "next fillup" is determined by odometer (chronological order by miles), not by date.

**Edge cases to handle:**
- Current fillup changed from full to partial: set mpg to null
- Odometer changed but no next full fillup exists: no additional update needed
- Multiple fillups with close odometer readings: only update the immediate next one

Do NOT change the existing validation logic or response format.
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors.
Test manually:
1. Create vehicle with 2+ full tank fillups
2. Edit middle fillup's gallons - verify its MPG updates
3. Edit middle fillup's odometer - verify both its MPG and next fillup's MPG update
  </verify>
  <done>PATCH /api/fillups/[id] recalculates MPG for edited fillup, and recalculates next fillup's MPG when odometer changes</done>
</task>

<task type="auto">
  <name>Task 2: Create manual recalculate endpoint</name>
  <files>src/app/api/fillups/[id]/recalculate/route.ts</files>
  <action>
Create a new POST endpoint at `/api/fillups/[id]/recalculate` that recalculates MPG for a specific fillup.

**Implementation:**

1. Create new route file at `src/app/api/fillups/[id]/recalculate/route.ts`

2. POST handler:
   - Authenticate user (same pattern as other fillup endpoints)
   - Fetch fillup with vehicle groupId
   - Verify user is member of vehicle's group (403 if not)
   - If fillup is not a full tank, return 400 with error "Cannot calculate MPG for partial fillups"
   - Find previous full fillup with odometer < current odometer (same query as POST handler)
   - Calculate MPG if previous exists, otherwise return 400 "No previous full fillup found for MPG calculation"
   - Update fillup with new MPG
   - Return updated fillup data (same format as GET /api/fillups/[id])

**Response format on success:**
```json
{
  "id": "...",
  "mpg": 28.5,
  // ... rest of fillup fields
}
```

**Error responses:**
- 401: Unauthorized
- 403: Not a member of vehicle's group
- 404: Fillup not found
- 400: "Cannot calculate MPG for partial fillups" or "No previous full fillup found for MPG calculation"
- 500: Database error

Use the same import patterns and auth flow as the existing `route.ts` in the same directory.
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors.
Test with curl:
```bash
curl -X POST http://localhost:3000/api/fillups/[fillup-id]/recalculate -H "Cookie: [auth-cookie]"
```
Should return updated fillup with recalculated MPG.
  </verify>
  <done>POST /api/fillups/[id]/recalculate endpoint exists and recalculates MPG for a single fillup</done>
</task>

<task type="auto">
  <name>Task 3: Add Recalculate MPG button to fillup details</name>
  <files>src/app/vehicles/[id]/fillups/page.tsx</files>
  <action>
Add a "Recalculate MPG" button in the expanded fillup details section for synced (non-pending) full tank fillups.

**Implementation:**

1. Add state for recalculation:
```typescript
const [recalculatingId, setRecalculatingId] = useState<string | null>(null)
```

2. Add handler function:
```typescript
async function handleRecalculateMpg(fillupId: string) {
  setRecalculatingId(fillupId)
  try {
    const response = await fetch(`/api/fillups/${fillupId}/recalculate`, {
      method: 'POST'
    })

    if (response.ok) {
      const updatedFillup = await response.json()
      // Update the fillup in state with new MPG
      setFillups(prev => prev.map(f =>
        f.id === fillupId ? { ...f, mpg: updatedFillup.mpg } : f
      ))
      setSuccessMessage('MPG recalculated successfully')
    } else {
      const data = await response.json()
      setError(data.error || 'Failed to recalculate MPG')
    }
  } catch {
    setError('Failed to recalculate MPG')
  } finally {
    setRecalculatingId(null)
  }
}
```

3. Add button in the expanded details section (inside the `{isExpanded && (` block), ONLY for:
   - Non-pending fillups (`!fillup.isPending`)
   - Full tank fillups (`fillup.isFull`)

Place the button in the actions row (same flex container as Edit and Delete buttons):
```tsx
{fillup.isFull && (
  <button
    type="button"
    onClick={() => handleRecalculateMpg(fillup.id)}
    disabled={recalculatingId === fillup.id}
    className="py-2 px-3 text-center text-sm bg-green-50 hover:bg-green-100 dark:bg-green-900/30 dark:hover:bg-green-900/50 text-green-600 dark:text-green-400 rounded-md transition-colors disabled:opacity-50"
  >
    {recalculatingId === fillup.id ? 'Recalculating...' : 'Recalculate MPG'}
  </button>
)}
```

The button should only appear for synced fillups (existing condition `!fillup.isPending` already wraps this section).
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors.
Test in browser:
1. Navigate to vehicle fillups page
2. Expand a full tank fillup
3. See "Recalculate MPG" button alongside Edit and Delete
4. Click button - should show loading state then success message
5. Expand a partial fillup - should NOT see the Recalculate button
  </verify>
  <done>Fillup details show "Recalculate MPG" button for full tank fillups, button triggers recalculation and updates displayed MPG</done>
</task>

</tasks>

<verification>
1. **Build passes:** `npm run build` completes without errors
2. **Type safety:** No TypeScript errors in modified files
3. **Edit recalculation:** Edit a fillup's gallons -> MPG updates
4. **Cascade recalculation:** Edit a fillup's odometer -> both current and next fillup MPG update
5. **Manual recalculation:** Click "Recalculate MPG" button -> MPG updates and success message shows
6. **Partial fillup:** Cannot recalculate MPG for partial fillups (button hidden, API returns 400)
</verification>

<success_criteria>
- Editing gallons recalculates MPG for that fillup
- Editing odometer recalculates MPG for that fillup AND the next fillup
- Manual recalculate button appears only for full tank fillups
- Manual recalculate endpoint returns updated MPG
- All existing fillup functionality continues to work (CRUD, pagination, offline)
</success_criteria>

<output>
After completion, create `.planning/phases/12-mpg-recalculation/12-01-SUMMARY.md`
</output>
